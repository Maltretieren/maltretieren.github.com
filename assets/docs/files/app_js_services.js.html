<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>app/js/services.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/CommentsCtrl.html">CommentsCtrl</a></li>
            
                <li><a href="../classes/ExportCtrl.html">ExportCtrl</a></li>
            
                <li><a href="../classes/GithubAuthService.html">GithubAuthService</a></li>
            
                <li><a href="../classes/GithubCtrl.html">GithubCtrl</a></li>
            
                <li><a href="../classes/GithubEditCtrl.html">GithubEditCtrl</a></li>
            
                <li><a href="../classes/GithubForkCtrl.html">GithubForkCtrl</a></li>
            
                <li><a href="../classes/GithubModalCtrl.html">GithubModalCtrl</a></li>
            
                <li><a href="../classes/GithubSrvc.html">GithubSrvc</a></li>
            
                <li><a href="../classes/ImportCtrl.html">ImportCtrl</a></li>
            
                <li><a href="../classes/RatingCtrl.html">RatingCtrl</a></li>
            
                <li><a href="../classes/TableCtrl.html">TableCtrl</a></li>
            
                <li><a href="../classes/ToasterController.html">ToasterController</a></li>
            
                <li><a href="../classes/WikiquoteCtrl.html">WikiquoteCtrl</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: app/js/services.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&quot;use strict&quot;;


myApp.value(&#x27;version&#x27;, &#x27;0.1&#x27;);

/**
 * Services are singleton objects used to share data
 * (e.g. among several controllers) and generally
 * encapsulate reusable pieces of code (since they can be
 * injected and offer their &quot;services&quot; in any part of your app
 * that needs them: controllers, directives, filters, other services etc).
 *
 * @class GithubAuthService
 * @constructor
 *
 * */
myApp.service(&quot;GithubAuthService&quot;, function ($http, $q, $rootScope, UserModel) {
    var github = null;

    return {
        /**
         * Description
         * @method instance
         * @param {} username
         * @param {} password
         * @return github
         */
        instance : function(username, password) {
            // this should ask for the UserModel - user object, and get the token from there...
            // the token is stored in localStorage, maybe a session store would work also?
            if(github===null) {
                console.info(&quot;new github instance &quot;+username);
                var oauthToken = localStorage.getItem(&quot;oauthToken&quot;);

                // search for info in localStorage
                if(typeof username === &#x27;undefined&#x27; &amp;&amp; typeof password === &#x27;undefined&#x27; &amp;&amp; UserModel.getUser() !== null) {
                    username = UserModel.getUser().name;
                    password = UserModel.getUser().password;
                    console.log(&quot;localStorage - Username: &quot;+username);
                }

                if(typeof username !== &#x27;undefined&#x27; &amp;&amp; typeof password !== &#x27;undefined&#x27;) {
                    console.log(&quot;using username/password workflow&quot;)
                    github = new Octokit({
                        username: username,
                        password: password,
                        auth: &quot;basic&quot;
                    });
                } else if(oauthToken != &quot;undefined&quot; &amp;&amp; oauthToken != null) {
                    console.log(&quot;using oath workflow&quot;);
                    github = new Octokit({
                        token: oauthToken,
                        auth: &quot;oauth&quot;
                    });
                } else {
                    console.info(&quot;oauthToken is not available or not valid&quot;);
                    console.info(&quot;Did you login via github? Otherwise you can connect via Basic Authentication... Please provide a username and password...&quot;)
                }
            } else {
                console.log(&quot;service already instanciated&quot;)
            }
            return github;
        },
        /**
         * Description
         * @return
         * @method requestCode
         * @return 
         */
        requestCode: function() {
            console.log(&quot;Request a new token, the page will be reloaded with code appended to the address...&quot;);
            // request a token, this generates a state random string, the string has to be validated after login
            jso_configure({
                &quot;github&quot;: {
                    client_id: config.github.client_id,
                    redirect_uri: config.github.redirection_url,
                    authorization: config.github.authorization
                }
            });

            $.oajax({
                jso_provider: &quot;github&quot;,
                jso_allowia: true
            });
        },
        /**
         * Description
         * @method requestToken
         * @param {} oauthCode
         * @return MemberExpression
         */
        requestToken: function(oauthCode) {
            var that = this;
            var tokenPromise = $q.defer();

            $http({method: &#x27;GET&#x27;, url: config.heroku.authenticate+&quot;&quot;+oauthCode}).
                success(function(data, status, headers, config) {
                    if(typeof data.token != &#x27;undefined&#x27;) {
                        console.log(&quot;Yaayy, got a token: &quot;+data.token);
                        localStorage.setItem(&quot;oauthToken&quot;, data.token);
                        tokenPromise.resolve();
                    } else {
                        console.log(&quot;It was not possible to get a token with the provided code&quot;);
                        tokenPromise.reject();
                    }
                }).
                error(function(data, status, headers, config) {
                    alert(&quot;Error while getting a token for the provided code&quot;);
                });

            return tokenPromise.promise;
        },
        /**
         * Description
         * @method userInfo
         * @return ObjectExpression
         */
        userInfo: function() {
            var self = this;
            /**
             * Description
             * @method user
             * @return userPromise
             */
            var user = function() {
                var githubInstance = self.instance();
                var user = githubInstance.getUser();

                var userPromise = user.getInfo();
                return userPromise;
            };

            return {
                /**
                 * Description
                 * @method user
                 * @return CallExpression
                 */
                user: function() { return user(); }
            }
        },
        /**
         * Description
         * @return
         * @method logout
         * @return 
         */
        logout: function() {
            github = null;
            UserModel.logout();
        }
    }
});

/**
 * GithubSrvc
 *
 * @class GithubSrvc
 * @constructor
 */
myApp.service(&quot;GithubSrvc&quot;, function (
    $rootScope, $q, $interval, GithubAuthService,
    UserModel, PollingSrvc, YamlSrvc, EditorSrvc, UrlSrvc, $http, $timeout) {

    return {
        /**
         * Description
         * @method requestCode
         * @return 
         */
        requestCode: function() {
            GithubAuthService.requestCode();
        },
        /**
         * Description
         * @method testAdmin
         * @return MemberExpression
         */
        testAdmin: function() {
            var deferred = $q.defer();
            var githubInstance = GithubAuthService.instance();
            console.log(config.github.user);
            console.log(config.github.repository);
            var repo = githubInstance.getRepo(config.github.user, config.github.repository);
            var branch = repo.getBranch(&quot;master&quot;);
            var promise = this.commit(&quot;Test if the logged in user has admistrative priveleges to commit to the repo&quot;, &quot;tests/results/test.admin&quot;, branch);
            promise.then(function() {
                console.log(&quot;testAdming: success&quot;);
				UserModel.setIsAdmin(true);
                deferred.resolve();
            }, function(reason) {
                console.log(&quot;testAdmin: errrrorrr&quot;);
				UserModel.setIsAdmin(false);
                deferred.reject();
            })
            return deferred.promise;
        },
		/**
		 * Description
		 * @method fork
		 * @param {} options
		 * @return 
		 */
		fork: function(options) {
            // options contain the name for the new github page and the site slogan
			var githubInstance = GithubAuthService.instance();
			if(githubInstance != null) {
                // this is the name of the original repo
                var repo = githubInstance.getRepo(config.github.user, config.github.repository);
                var promise = $q.when(repo.fork());
                return promise;
            } else {
                console.log(&quot;no token provided... Please login&quot;);
            }
		},
        /**
         * Description
         * @method renameRepo
         * @param {} forkName
         * @return CallExpression
         */
        renameRepo: function(forkName) {
			console.log(&quot;rename repo to &quot;+forkName);
            if(!forkName || forkName.length &lt; 5){
				forkName = UserModel.getUser().name+&quot;.github.com&quot;
			}
			
            var that = this;
            var patch = {
                name: forkName
            };
            var githubInstance = GithubAuthService.instance();
            //var userName = UserModel.getUser().name;
            var repo = githubInstance.getRepo(UserModel.getUser().name, config.github.repository);
            return $q.when(repo.updateInfo(patch)).then(function(res) {
                console.log(&quot;Repository renamed...&quot;)
                //that.renameBranch(forkName, &quot;heads/master&quot;);
            })
        },
        /**
         * Description
         * @method batchDelete
         * @param {} forkName
         * @return 
         */
        batchDelete: function(forkName) {
            var githubInstance = GithubAuthService.instance();
            var repo = githubInstance.getRepo(UserModel.getUser().name, forkName);
            var branch = repo.getBranch(&quot;master&quot;);

			// polling for the posts dir every second until rename complete,
			// then start delete every second....
			(function tick(path) {
				$q.when(branch.contents(path)).then(function(res) {
					console.log(&quot;cleanup of _posts...&quot;);
					var i = 0;
					$interval(function() {
						if(res[i].type === &quot;file&quot;) {
							branch.remove(res[i].path, &quot;deleted&quot;);
						} else {
							console.log(res[i].path + &quot; is a folder - delete the content instead&quot;);
							tick(res[i].path);
						}
						i++;
					}, 1500, res.length);
				}, function(err) {
					$timeout(tick(&quot;_posts&quot;), 1000);
				});
			})();

        },
        /**
         * Description
         * @method getContents
         * @param {} path
         * @return 
         */
        getContents: function(path) {
            var githubInstance = GithubAuthService.instance();
			var readyPromise = $q.defer();
			
			if(githubInstance != null) {
				var repo = githubInstance.getRepo(config.github.user, config.github.repository);
				var branch = repo.getBranch(&quot;master&quot;);
				var self = this;

				console.log(path);
				var contentArray = {};
				
				var folderCounter = 0;
				var fileCounter = 0;
				
				// preprocess response to seperate files/folders
				var filesPath = [];
				var foldersPath = [];

				var j = 0;
				var fileCountDeferred = $q.defer();
				// find all files to export also in subfolders
				/**
				 * Description
				 * @method fileCount
				 * @param {} path
				 * @return 
				 */
				var fileCount = function(path) {
					branch.contents(path).then(function(response) {
						var res = JSON.parse(response);

						for(var i=0; i&lt;res.length;i++) {
							if(res[i].type === &quot;file&quot;) {
								filesPath.push(res[i].path);
							} else {
								foldersPath.push(res[i].path);
							}
						}

						if(j!==foldersPath.length) {
							var newFolder = foldersPath[j++];
							console.log(newFolder);
							fileCount(newFolder);
						} else {
							fileCountDeferred.resolve(filesPath);
						}
					});
				};
				// this is the toplevel folder to search for files
				fileCount(path);

				return fileCountDeferred.promise;
			} else {
				readyPromise.reject(&quot;Could not init githubInstance&quot;);
				return readyPromise.promise;
			}
        },
		/**
		 * Description
		 * @method getFiles
		 * @param {} fileNames
		 * @return MemberExpression
		 */
		getFiles: function(fileNames) {
			var self = this;
			
			var githubInstance = GithubAuthService.instance();
            var repo = githubInstance.getRepo(config.github.user, config.github.repository);
            var branch = repo.getBranch(&quot;master&quot;);
						
			var contents = {};
			var i=1;
			
			var fileDeferred = $q.defer();
			/**
			 * Description
			 * @method doGet
			 * @param {} fileName
			 * @return 
			 */
			var doGet = function(fileName) {
				var fileName = fileName;
				self.getContent(fileName).then(function(response) {
					contents[fileName] = response.content;
                    fileDeferred.notify(i);
                    if(i !== fileNames.length) {
						doGet(fileNames[i++]);
					} else {
						fileDeferred.resolve(contents);
					}
					
				});
			}
			// trigger with first, proceed all with a promise loop
			doGet(fileNames[0]);
			
			return fileDeferred.promise;
		},
        /**
         * Description
         * @method deleteBranch
         * @param {} forkName
         * @param {} branchName
         * @return CallExpression
         */
        deleteBranch: function(forkName, branchName) {
			var that = this;
			var githubInstance = GithubAuthService.instance();
			var repo = githubInstance.getRepo(UserModel.getUser().name, forkName);
			return repo.git.deleteRef(branchName).then(function(result) {
				console.log(&quot;deleted branch&quot;+branchName);
				//that.renameBranch(forkName);
			});
        },
        /**
         * Description
         * @method renameBranch
         * @param {} forkName
         * @return CallExpression
         */
        renameBranch: function(forkName) {
			var that = this;
			var githubInstance = GithubAuthService.instance();
			var repo = githubInstance.getRepo(UserModel.getUser().name, forkName);
			return repo.git.deleteRef(&quot;heads/master&quot;).then(function(result) {
				console.log(&quot;deleted master branch&quot;);
				//that.createBranch(forkName, &quot;master&quot;);
			});
        },
        /**
         * Description
         * @method createBranch
         * @param {} forkName
         * @param {} branchName
         * @return CallExpression
         */
        createBranch: function(forkName, branchName) {
			var that = this;
			var githubInstance = GithubAuthService.instance();
			var repo = githubInstance.getRepo(UserModel.getUser().name, forkName);
			console.log(&quot;switch to template branche&quot;);
			var branch = repo.getBranch(&quot;template&quot;);
			var forkName = forkName;
			console.log(&quot;create master branch from template&quot;);
			return branch.createBranch(&quot;master&quot;).then(function() {
				console.log(&quot;master branch created from template branch&quot;);
                branch = repo.getBranch(&quot;master&quot;);
			});
        },
        /**
         * Description
         * @method postProcess
         * @param {} path
         * @param {} replace
         * @param {} repositoryName
         * @return MemberExpression
         */
        postProcess: function(path, replace, repositoryName) {
            var self = this;
            var content = this.getContent(path);
            var deferred = $q.defer();
            content.then(function(data) {
                var configLine = data.content.split(&#x27;\n&#x27;);
                var newConfigData = &quot;&quot;;
                for(var i = 0;i &lt; configLine.length;i++){
                    var split = configLine[i].split(&quot;:&quot;);
                    var replaceKey = split[0].trim();
                    var replaceHit = replace[replaceKey];
                    if(typeof replaceHit != &#x27;undefined&#x27;) {
                       console.log(&quot;HITTTTTT&quot;)
                       newConfigData += split[0]+&quot;: &quot;+replaceHit+&quot;\n&quot;;
                    } else {
                       newConfigData += configLine[i]+&quot;\n&quot;;
                    }
                }
                //console.log(newConfigData);
                var githubInstance = GithubAuthService.instance();
                var repo = githubInstance.getRepo(UserModel.getUser().name, repositoryName);
                var branch = repo.getBranch(&quot;master&quot;);
                var commitPromise = self.commit(newConfigData, path, branch, false);
                commitPromise.then(function() {
                    console.log(&quot;updated backend config data&quot;);
                    deferred.resolve(newConfigData);
                });
            });
            return deferred.promise;
        },
        /**
         * Description
         * @method getContent
         * @param {} path
         * @return 
         */
        getContent: function(path) {
            var githubInstance = GithubAuthService.instance();
            var deferred = $q.defer();
			
			if(githubInstance != null) {
				var repo = githubInstance.getRepo(config.github.user, config.github.repository);
				var branch = repo.getBranch(&quot;master&quot;);
				var contents = branch.read(path, false)

				contents.then(function(result) {
				   deferred.resolve(result);
				});
				return deferred.promise;
			} else {
				deferred.reject(&quot;Could not init githubInstance&quot;);
				return deferred.promise;
			}
        },
        /**
         * Description
         * @method editContent
         * @param {} path
         * @return 
         */
        editContent: function(path) {
            var self = this;
            var path = path;
			
			// get the content you want to edit from github
            var githubInstance = GithubAuthService.instance();
			var deferred = $q.defer();
			if(githubInstance != null) {
				var repo = githubInstance.getRepo(config.github.user, config.github.repository);
				var branch = repo.getBranch(&quot;master&quot;);
				var contents = branch.read(path, false)
				
				// if the content is ready, fill the editor, when the save button is clicked a promise is resolved...
				contents.then(function(result) {
					var frontMatter = YamlSrvc.parse(result.content);
					EditorSrvc.open(frontMatter.content);
					deferred.resolve(frontMatter);
				});
				return deferred.promise;
			} else {
				deferred.reject(&quot;Could not init githubInstance&quot;);
				return deferred.promise;
			}
        },
		/**
		 * Description
		 * @method commit
		 * @param {} text
		 * @param {} path
		 * @param {} branch
		 * @param {} showMessage
		 * @param {} force
		 * @return MemberExpression
		 */
		commit: function(text, path, branch, showMessage, force) {
			if(typeof branch === &#x27;undefined&#x27;) {
				var githubInstance = GithubAuthService.instance();
				var repo = githubInstance.getRepo(config.github.user, config.github.repository);
				branch = repo.getBranch(&quot;master&quot;);
			}
			var contents = {};
            if(typeof text == &#x27;string&#x27;) {
                contents[path] = text;
            } else {
               contents = text;
            }

            var deferred = $q.defer();

            branch.writeMany(contents, &#x27;Save from GUI&#x27;, force).then(function() {
                deferred.resolve();
				if(showMessage) {
					$rootScope.$broadcast(&#x27;Toast::githubCommitSuccess&#x27;);
				}
            }, function(error) {
                console.log(&quot;there was a commit error&quot;);
                deferred.reject();
            });
            return deferred.promise;
        },
		/**
		 * Description
		 * @method commitMany
		 * @param {} posts
		 * @param {} message
		 * @param {} showMessage
		 * @param {} force
		 * @return MemberExpression
		 */
		commitMany: function(posts, message, showMessage, force) {
			var githubInstance = GithubAuthService.instance();
			var repo = githubInstance.getRepo(config.github.user, config.github.repository);
			var branch = repo.getBranch(&quot;master&quot;);

            var deferred = $q.defer();
            branch.writeMany(posts, message, force).then(function() {
                deferred.resolve();
				if(showMessage) {
					$rootScope.$broadcast(&#x27;Toast::githubCommitSuccess&#x27;);
				}
            }, function(error) {
                console.log(&quot;there was a commit error&quot;);
                deferred.reject();
            });
            return deferred.promise;
        },
        /**
         * Description
         * @method deleteContent
         * @param {} path
         * @return CallExpression
         */
        deleteContent: function(path) {
            var githubInstance = GithubAuthService.instance();
            var repo = githubInstance.getRepo(config.github.user, config.github.repository);
            var branch = repo.getBranch(&quot;master&quot;);
            return branch.remove(path, &#x27;Deleted Post from GUI&#x27;);
        }
    }
});

// Inspired by http://joelhooks.com/blog/2013/04/24/modeling-data-and-state-in-your-angularjs-application/
myApp.service(&quot;UserModel&quot;, function ($rootScope) {
	this.user = {};
    /**
     * Description
     * @method serializeUser
     * @param {} user
     * @return 
     */
    var serializeUser = function(user) {
        var userJson = JSON.stringify(user);
        localStorage.setItem(&quot;user&quot;, userJson);
    }

	/**
	 * Description
	 * @method setUserName
	 * @param {} userName
	 * @return 
	 */
	this.setUserName = function(userName) {
		this.user.name = userName;
        $rootScope.$broadcast(&#x27;UserModel::userLoggedIn&#x27;);
        serializeUser(this.user);
	};
    /**
     * Description
     * @method setIsAdmin
     * @param {} isAdmin
     * @return 
     */
    this.setIsAdmin = function(isAdmin) {
        this.user.isAdmin = isAdmin;
        serializeUser(this.user);
    },
    /**
     * Description
     * @method setPassword
     * @param {} password
     * @return 
     */
    this.setPassword = function(password) {
        this.user.password = password;
        serializeUser(this.user);
    },
	/**
	 * Description
	 * @method logout
	 * @return 
	 */
	this.logout = function() {
		this.user = {};
		localStorage.clear();
		$rootScope.$broadcast(&#x27;UserModel::userLoggedOut&#x27;);
	}
	/**
	 * Description
	 * @method getUser
	 * @return 
	 */
	this.getUser = function() {
		var userString = localStorage.getItem(&quot;user&quot;);
		if(typeof userString !== &#x27;undefined&#x27;) {
			var userObject = JSON.parse(userString);
			return userObject;
		} else {
			return null;
		}
	}
});

/**
 This is a helper function
 **/
myApp.service(&quot;UrlSrvc&quot;, function ($window) {
    /**
     * Description
     * @method getParams
     * @param {} url
     * @param {} paramName
     * @return MemberExpression
     */
    var getParams = function (url, paramName) {
		var urlParams;
		(
/**
 * Description
 * @method onpopstate
 * @return 
 */
$window.onpopstate = function () {
			/**
			 * Description
			 * @method decode
			 * @param {} s
			 * @return CallExpression
			 */
			var match,
				pl     = /\+/g,  // Regex for replacing addition symbol with a space
				search = /([^&amp;=]+)=?([^&amp;]*)/g,
				decode = function (s) { return decodeURIComponent(s.replace(pl, &quot; &quot;)); },
				query  = url.split(&#x27;?&#x27;)[1];

			urlParams = {};
			while (match = search.exec(query))
				urlParams[decode(match[1])] = decode(match[2]);
		})();
		return urlParams[paramName];
	}

    /**
     * Description
     * @method getUrl
     * @return MemberExpression
     */
    var getUrl = function () {
        return window.location.search;
    }

	/**
	 * Description
	 * @method parseDateTitle
	 * @param {} path
	 * @return ObjectExpression
	 */
	var parseDateTitle = function (path) {	
		var splif = path.split(&quot;-&quot;);
		var title = &quot;&quot;
		var date = splif[0].split(&quot;/&quot;)[1]+&quot;-&quot;+splif[1]+&quot;-&quot;+splif[2];
		for(var i=3;i&lt;splif.length;i++) {
			if(i!==splif.length-1) {
				title += splif[i]+&quot; &quot;;
			} else {
				title += splif[i].split(&quot;.&quot;)[0];
			}
		}
		return {
			date: date,
			title: title
		}
	}
	
	return {
		getParams: getParams,
		parseDateTitle: parseDateTitle,
        getUrl: getUrl
	}
});

myApp.service(&quot;PollingSrvc&quot;, function ($q, $timeout, UserModel, GithubAuthService) {
        /**
         * Description
         * @method poll
         * @param {} repoName
         * @param {} branchName
         * @return MemberExpression
         */
        var poll = function (repoName, branchName) {
        var resource = &quot;README.md&quot;;
        var deferred = $q.defer();
        // poll for availability - implement as promise, resolve as soon as it is available
		var githubInstance = GithubAuthService.instance();
		var repo = githubInstance.getRepo(UserModel.getUser().name, repoName);
		var branch = repo.getBranch(branchName);
		var repoName = repoName;
		var branchName = branchName;
		
		/**
		 * Description
		 * @method restartPolling
		 * @return 
		 */
		var restartPolling = function() {
		    var promise = branch.read(resource,false);
			promise.then(function(res) {
				console.log(&quot;branch available&quot;)
				deferred.resolve();
			}, function(err) {
				/**
				 * Description
				 * @method restart
				 * @return 
				 */
				var restart = function(){
					restartPolling(repoName, branchName)
				}
				$timeout(restart, 2000);
			});
		}
		restartPolling();

        return deferred.promise;
    };
    return { checkForBranchContent: poll }
});

/**
 * YamlSrvc can parse files with frontmatter (normal post)
 * and the _config.yaml without frontmatter
 */
myApp.service(&quot;YamlSrvc&quot;, function () {
    /**
     * Description
     * @method parse
     * @param {} content
     * @return response
     */
    var parse = function (content) {
		var response = {};

        // if there is a frontmatter available (parsing of a post source code)...
		var contentSplit = content.split(&quot;---&quot;);
        var lineSplit = 0;

        // different handle for _config.yml and normal sites
        if(contentSplit.length === 3) {
            lineSplit = contentSplit[1].split(&quot;\n&quot;);
            // trim leading line breaks
            var trimmedLinebreaks = contentSplit[2].replace(/^[\r\n]+|[\r\n]+$/g,&#x27;&#x27;);
            response[&quot;content&quot;] = trimmedLinebreaks;
        } else if(contentSplit.length === 1) {
            response[&quot;content&quot;] = contentSplit[0];
        }

		var remember = &quot;&quot;;

        // parse the text to an js object
		for(var i=0; i&lt;lineSplit.length; i++) {
			if(lineSplit[i] !== &quot;&quot;) {
				var line = lineSplit[i].split(&quot;:&quot;);
				if(line.length===2 &amp;&amp; line[1].trim() !== &quot;&quot;) {
                    // deal with boolean
                    var value = line[1].trim();
                    if(value === &quot;true&quot; || value === &quot;false&quot;) {
						// convert to a boolean object
                        value = (line[1].trim() === &#x27;true&#x27;);
                    } else {
						value = line[1].trim();
					}
                    response[line[0]] = value;
				} else {
					var element = line[0].split(&quot;-&quot;);
                    var value = &quot;&quot;;
					if(element.length === 1) {
						value = element[0].trim();
                        remember = value;
						response[value] = [];
					} else {
                        value = element[1].trim();
                        if(value === &quot;true&quot; || value === &quot;false&quot;) {
                            value = Boolean(element[1].trim());
						    response[remember].push(value);
                        }
                        response[remember].push(value);
					}
				}
			}
		}
		return response;
    };
	/**
	 * Description
	 * @method create
	 * @param {} content
	 * @return response
	 */
	var create = function (content) {
		var response = &quot;---\n&quot;;
		for (var key in content) {
			if(key !== &quot;content&quot;) {
				response += key+&quot;:&quot;;
				if (typeof content[key] === &#x27;string&#x27;|| typeof content[key] === &#x27;boolean&#x27;) {
					response += &quot; &quot;+content[key]+&quot;\n&quot;;
				} else if(content[key].length!==0) {
					for(var i=0; i&lt;content[key].length; i++) {
						response += &quot;\n - &quot;+content[key][i]+&quot;\n&quot;;
					}
				} else {
					response += &quot;\n&quot;;
				}
			}
		}
		response += &quot;---\n&quot;;
		// remove empty lines
		response = response.replace(/^\s*\n/gm, &quot;&quot;);
		
		response += content[&#x27;content&#x27;];
		return response;
    };


    return { 
		parse: parse,
		create: create
	}
});

myApp.service(&quot;EditorSrvc&quot;, function () {
    /**
     * Description
     * @method getEditorContent
     * @return MemberExpression
     */
    var getEditorContent = function() {
        return $(&#x27;#target-editor&#x27;).markdown()[0].value;
    };

    /**
     * Description
     * @method showContentInEditor
     * @param {} editorContent
     * @return 
     */
    var showContentInEditor = function(editorContent) {
        $(&#x27;#target-editor&#x27;).markdown({
            savable:false,
            height:500,
            /**
             * Description
             * @method onFocus
             * @param {} e
             * @return 
             */
            onFocus: function(e) {
                console.log(&quot;editor focused&quot;)
            }
        });
        $(&#x27;#target-editor&#x27;).val(editorContent);
        $(&#x27;#target-editor&#x27;).show();
    }

    return {
        getEditorContent: getEditorContent,
        open: showContentInEditor
    }
});

myApp.service(&quot;PollingImgSrvc&quot;, function ($q, $timeout) {

    /**
     * Description
     * @method poll
     * @param {} repoName
     * @return MemberExpression
     */
    var poll = function (repoName) {
        var deferred = $q.defer();

        /**
         * Description
         * @method pollForImg
         * @return 
         */
        var pollForImg = function() {
            if(!angular.isUndefined(repoName)) {
                console.log(&quot;poll&quot;);
                var img = new Image();

                /**
                 * Description
                 * @method onload
                 * @return 
                 */
                img.onload = function () {
                    console.log(&quot;yehh&quot;);
                    deferred.resolve();
                }
                /**
                 * Description
                 * @method onerror
                 * @return 
                 */
                img.onerror = function () {
                    console.log(&quot;oh noooo&quot;);
                    /**
                     * Description
                     * @method pollForImage
                     * @return 
                     */
                    var pollForImage = function () {
                        pollForImg();
                    }
                    $timeout(pollForImage, 30000);
                }
                img.src = &quot;https://&quot; + repoName + &quot;/app/img/ping.gif&quot;;
            } else {
                return deferred.reject(&quot;fn should be called with a repoName&quot;)
            }
        }
        pollForImg();

        return deferred.promise;
    };
    return { checkReady: poll }
});

myApp.service(&quot;StyleSwitcher&quot;, function () {
	return { 
/**
  * Description
  * @method switch
  * @param {} styleName
  * @return 
  */
 switch: function(styleName) {
		console.log(&quot;switch to style: &quot;+styleName);
		if(typeof styleName!==&#x27;undefined&#x27; &amp;&amp; styleName !== &#x27;&#x27;) {
			var i, link_tag ;
			  for (i = 0, link_tag = document.getElementsByTagName(&quot;link&quot;) ;
				i &lt; link_tag.length ; i++ ) {
				if ((link_tag[i].rel.indexOf( &quot;stylesheet&quot; ) != -1) &amp;&amp;
				  link_tag[i].title) {
				  link_tag[i].disabled = true ;
				  if (link_tag[i].title == styleName) {
					link_tag[i].disabled = false ;
				  }
				}
			  }
		}
	}}
});


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
